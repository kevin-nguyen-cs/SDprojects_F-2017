<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"><title>Demo Programs on Evaluating Constraints on MDELite Databases</title></head>
<body>
<h1 style="text-align: center;"><span style="font-family: Helvetica,Arial,sans-serif;">Illustrative Constraints on MDELite Databases</span></h1>
<span style="font-family: Helvetica,Arial,sans-serif;"><br><span style="font-family: Helvetica,Arial,sans-serif;">Consider the following database. &nbsp;There is an</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">m-n</span> association between tables <span style="font-weight: bold;">student</span> and <span style="font-weight: bold;">course</span>. &nbsp;Association normalization&nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;">creates a third table <span style="font-weight: bold;">takes</span> that pairs each <span style="font-weight: bold;">student</span> with each <span style="font-weight: bold;">course</span> that student takes. &nbsp;<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 80px; font-family: monospace;"><big><big><big><small><small>dbase(sc,[course,student,takes]).<br>table(course,[cid,"name"]).<br>table(student,[sid,"name"]).<br>table(takes,[tid,cid,sid])</small></small></big><big><big><small><small>.</small></small></big></big></big></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">There are many unique structural constraints to be verified in this database:<br></span><ol><li><span style="font-family: Helvetica,Arial,sans-serif;"><a href="#2:_Checking_Field_Value_Uniqueness">No two <span style="font-weight: bold;">students</span> have the same name</a>.</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><a href="#3:_Checking_Non-Null_Fields_">Every <span style="font-weight: bold;">takes</span> tuple has a non-null <span style="font-weight: bold;">student</span> ID and a non-null <span style="font-weight: bold;">course</span> ID</a>.</span></li><li><a href="#4:_Checking_Existence_Constraints"><span style="font-family: Helvetica,Arial,sans-serif;">Every <span style="font-weight: bold;">takes</span> tuple requires its <span style="font-weight: bold;">student</span> ID to correspond&nbsp; to a tuple in the <span style="font-weight: bold;">student</span> table; same for <span style="font-weight: bold;">course</span> ID.</span></a></li><li><a href="#5:_No_Field-value_Combinations_are"><span style="font-family: Helvetica,Arial,sans-serif;">No <span style="font-weight: bold;">takes</span> (cid,sid) is duplicated.</span></a></li></ol><span style="font-family: Helvetica,Arial,sans-serif;">But also some that are application specific:<br></span><ol start="5"><li><a href="#6:_Multi-Table_Constraints_"><span style="font-family: Helvetica,Arial,sans-serif;">The compilers and database courses must have a minimum enrollment of 2 students.</span></a></li><li><span style="font-family: Helvetica,Arial,sans-serif;"><a href="#7:_Multi-Table_Constraints_--_Joins">Every student should take one course.</a><br></span></li></ol><span style="font-family: Helvetica,Arial,sans-serif;">The examples in this document illustrate how each of these constraints can be evaluated.<br><br>Remember, </span><span style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;">Java
Streams are stateless, so one has to create an operation that updates a
stateful object which retains the list of errors that have been
encountered. &nbsp;This is an <span style="font-weight: bold;">ErrorReport</span> object, whose usage is:<br></span><pre style="margin-left: 80px;"><big>ErrorReport er = new ErrorReport();<br><br>... er.add("this is error1");<br>... er.add("this is error2");<br><br>er.printReport(System.out);<br></big></pre><span style="font-family: Helvetica,Arial,sans-serif; font-weight: bold;">Table of Contents</span><br style="font-family: Helvetica,Arial,sans-serif;"><ol style="font-family: Helvetica,Arial,sans-serif;"><li><a href="#1:_Checking_Unique_Tuple_IDs">Checking Unique Tuple IDs</a></li><li><a href="#2:_Checking_Field_Value_Uniqueness"> Checking Field Value Uniqueness Constraints</a></li><li><a href="#3:_Checking_Non-Null_Fields_">Checking Non-Null Fields&nbsp;</a></li><li><a href="#4:_Checking_Existence_Constraints">Checking Existence Constraints</a></li><li><a href="#5:_No_Field-value_Combinations_are"> No Field-value Combinations are Duplicate</a></li><li><a href="#6:_Multi-Table_Constraints_"> Multi-Table Constraints&nbsp;</a></li><li><a href="#7:_Multi-Table_Constraints_--_Joins">Multi-Table Constraints -- Joins</a></li></ol><h2><a name="1:_Checking_Unique_Tuple_IDs"></a><span style="font-family: Helvetica,Arial,sans-serif;">1: Checking Unique Tuple IDs</span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">This
is a test that generally is unneeded, given that tuple IDs are
generated. &nbsp;Unique is a class whose
sole purpose is to register values and report duplicates. &nbsp;A
standard use is verifying every <span style="font-weight: bold;">course</span> tuple has a unique ID.<br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void UniqueID() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table course = db.getTableEH("course");<br>        ErrorReport er = new ErrorReport();<br>        <br>        // Manual<br>        Unique u = new Unique(course, "cid", er);<br>        course.stream().forEach(t -> u.add(t));<br>        <br>        // MDELite built-in support<br>        isUnique(course, "cid", er);<br>        <br>        // finish<br>        er.printReport(System.out);<br>    }<br></big></pre><h2><a name="2:_Checking_Field_Value_Uniqueness"></a><span style="font-family: Helvetica,Arial,sans-serif;">2: Checking Field Value Uniqueness Constraints</span></h2><span style="font-family: Helvetica,Arial,sans-serif;">Another common constraint is a column with unique values for each tuple in a table, such as </span><span style="font-family: Helvetica,Arial,sans-serif;">no two students have the same name.</span><span style="font-family: Helvetica,Arial,sans-serif;"> Again, a Unique report object is used for this task. </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void UniqueName() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table student = db.getTableEH("student");<br>        ErrorReport er = new ErrorReport();<br>        <br>        // Manual way<br>        Unique u = new Unique(student, "name", er);<br>        student.stream().forEach(t -> u.add(t));<br>        <br>        // MDELite built-in support<br>        isUnique(student, "name", er);<br>        <br>        // finally<br>        er.printReport(System.out);<br>    }<br></big></pre><h2><a name="3:_Checking_Non-Null_Fields_"></a><span style="font-family: Helvetica,Arial,sans-serif;">3: Checking Non-Null Fields&nbsp;</span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">E</span></span><span style="font-family: Helvetica,Arial,sans-serif;">very <span style="font-weight: bold;">takes</span> tuple has a non-null <span style="font-weight: bold;">student</span> ID and a non-null <span style="font-weight: bold;">course</span> ID</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">. A single parameterized method, <span style="font-family: Courier New,Courier,monospace;">testNull</span>, can be
used to verify that particular fields of a table are non-null.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void NonNull() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table takes = db.getTableEH("takes");<br>        ErrorReport er = new ErrorReport();<br>        <br>        // manual way<br>        testNull(takes, "cid", er);<br>        testNull(takes, "sid", er);<br>        <br>        // MDELite built-in support<br>        Predicate<Tuple> cidIsNull = t->t.isNull("cid");<br>        iftest(takes,cidIsNull,"cid is null",er);<br>        <br>        Predicate<Tuple> sidIsNull = t->t.isNull("sid");<br>        iftest(takes,sidIsNull,"sid is null",er);<br>        <br>        // finish<br>        er.printReport(System.out);<br>    }<br><br>    void testNull(Table tab, String fieldName, ErrorReport er) {<br>        tab.stream()<br>           .filter(t -> t.isNull(fieldName))<br>           .forEach(t -> er.add("%s(%s...) has null %s field", <br>                tab.getName(), t.get("tid"), fieldName));<br>    }<br></big></pre><h2 style="color: rgb(0, 0, 0); font-style: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;"><a name="4:_Checking_Existence_Constraints"></a>4: &nbsp;Checking Existence Constraints</h2><span style="font-family: Helvetica,Arial,sans-serif;">An existence constraint asserts a tuple-id value in one table corresponds
to an existing tuple in another. Example: the</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">student</span> ID in each <span style="font-weight: bold;">takes</span> tuple corresponds to a tuple in the <span style="font-weight: bold;">student</span> table. &nbsp;Existence is checked by the <span style="font-weight: bold;">exists</span> method of MDELite.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void Existence() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table takes = db.getTableEH("takes");<br>        Table course = db.getTableEH("course");<br>        ErrorReport er = new ErrorReport();<br>        <br>        // Manual: one way -- a tuple at a time<br>        takes.stream()<br>             .filter(t -> (!course.exists("cid", t.get("cid"))))<br>             .forEach(t -> {<br>                er.add("takes(%s,..) has invalid cid value (%s)",<br>                       t.get("tid"), t.get("cid"));<br>                });<br>        <br>        // Manual: another way -- compute a table of offending tuples<br>        Table offendingTakes = Table.antiSemijoin(takes, "cid", course, "cid");<br>        offendingTakes<br>                .stream()<br>                .forEach(t-> er.add("takes(%s,..) has invalid cid value (%s)",<br>                        t.get("tid"), t.get("cid")));<br>        <br>        // MDELite built-in support<br>        isLegit(takes, "cid", course, "cid", er);<br>        <br>        // finish<br>        try {er.printReport(System.out);} catch (Exception ex) {}<br>        <br>    }<br></big></pre><h2 style="color: rgb(0, 0, 0); font-style: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;"><a name="5:_No_Field-value_Combinations_are"></a>5: No Field-Value Combinations are Duplicate</h2><span style="font-family: Helvetica,Arial,sans-serif;">This
is a slight variation on unique field values. &nbsp;The trick is to
create a virtual field whose value is the concatenation of its
underlying multiple concrete fields. &nbsp;Here is how Constraint 4
could be written:</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void UniqueCombo() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table takes = db.getTableEH("takes");<br>        ErrorReport er = new ErrorReport();<br>        Unique u = new Unique(takes, "combo", er);<br><br>	// test for duplicates on artificial field<br>        for (Tuple t : takes.tuples()) {<br>            String c = combo(t);<br>            u.add(t,c);<br>        }<br><br>	// finally<br>        er.printReport(System.out);<br>    }<br><br>    String combo(Tuple t) {<br>        return "'" + t.get("cid") + "," + t.get("sid") + "'"; // quotes optional<br>    }<br></big></pre><h2><a name="6:_Multi-Table_Constraints_"></a><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span>6: Multi-Table Constraints&nbsp; </span></h2><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">Constraint 5 counts the number of <span style="font-weight: bold;">takes</span> (really <span style="font-weight: bold;">student</span>)
tuples enrolled in each database and compiler course and checks that at
least 2 students are enrolled. &nbsp;This is the first use of the
tuple.map() method which converts a tuple, 'this', into a subtable of
existing tuples to which it is related. &nbsp;The number of tuples in
this subtable is counted and tested whether or not it is &lt; 2.</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void attendance() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table course = db.getTableEH("course");<br>        Table takes = db.getTableEH("takes");<br>        ErrorReport er = new ErrorReport();<br><br>	// check constraint<br>        course.stream()<br>          .filter(t -> t.is("name", "compilers") || t.is("name", "databases"))<br>          .filter(t -> t.join("cid", takes, "cid").size() < 2)<br>          .forEach(t -> er.add("%s course does not have enough students", t.get("name")));<br><br>	// finally<br>        er.printReport(System.out);<br>    }<br></big></pre><h2 style="color: rgb(0, 0, 0); font-style: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;"><a name="7:_Multi-Table_Constraints_--_Joins"></a>7: Multi-Table Constraints -- Joins</h2><span style="font-family: Helvetica,Arial,sans-serif;">Constraint 6 joins tables <span style="font-weight: bold;">student</span>, <span style="font-weight: bold;">takes</span>, and <span style="font-weight: bold;">courses</span>
to evaluate a required condition that every student is enrolled in one
course. &nbsp;This constraint is complicated enough to have multiple
reasonable implementations. &nbsp;The first is:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void jConstraint() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table student = db.getTableEH("student");<br>        Table takes = db.getTableEH("takes");<br>        Table course = db.getTableEH("course");<br>        ErrorReport er = new ErrorReport();<br><br>	// check constraint<br>        student.stream().forEach(s -> {<br>            Table shortTakes = s.rightSemiJoin("sid", takes, "sid");<br>            Table joined = Table.join(shortTakes, "cid", course, "cid");<br>            if (joined.size() == 0) {<br>                er.add("student %s is not taking a database course", s.get("name"));<br>            }<br>        });<br><br>	// finally<br>        er.printReport(System.out);<br>    }<br></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">The second is:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace;"><big>    void jConstraint2() {<br>        DB db = DB.readDataBase(testdata+"/StudentCourse.sc.pl");<br>        Table student = db.getTableEH("student");<br>        Table takes = db.getTableEH("takes");<br>        Table course = db.getTableEH("course");<br>        Table tc = Table.join(takes,"cid", course, "cid");<br>        ErrorReport er = new ErrorReport();<br><br>	// check constraint<br>        student.stream()<br>               .filter(s -> s.rightSemiJoin("sid",tc,"takes.sid").size()==0)<br>               .forEach(s ->er.add("student %s is not taking a database course", <br>                       s.get("name")));<br><br>	// finally<br>        er.printReport(System.out);<br>    }<br></big></pre><br><span style="font-family: Helvetica,Arial,sans-serif;"><br></span>
</body></html>

